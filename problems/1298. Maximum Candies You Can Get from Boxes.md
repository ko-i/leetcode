> https://leetcode-cn.com/problems/maximum-candies-you-can-get-from-boxes/

``` rust
use std::collections::HashSet;

impl Solution {
    pub fn max_candies(status: Vec<i32>, candies: Vec<i32>, keys: Vec<Vec<i32>>, contained_boxes: Vec<Vec<i32>>, initial_boxes: Vec<i32>) -> i32 {
        // å½“å‰æ‰‹ä¸­çš„ç›’å­ä»¬
        let mut boxes_set: HashSet<i32> = initial_boxes.iter().cloned().collect();
        // å½“å‰æ‰‹ä¸­çš„ğŸ”‘ä»¬
        let mut keys_set = HashSet::new();
        // ğŸ¬æ•°é‡
        let mut ans = 0;
        
        // å¾ªç¯æ ‡è®°ï¼Œæœ¬è½®æ˜¯å¦æ‰“å¼€çš„æ–°çš„ç›’å­
        let mut have_new_boxes = true;
        while have_new_boxes {
            have_new_boxes = false;
            
            let mut t_set = HashSet::with_capacity(boxes_set.len() * 2);
            for cur_box in boxes_set.drain() {
                if status[cur_box as usize] == 1 || keys_set.contains(&cur_box) {
                    // å¦‚æœç®±å­æ˜¯æ‰“å¼€çš„ï¼Œæˆ–è€…æœ‰è¿™ä¸ªç®±å­çš„ğŸ”‘
                    ans += candies[cur_box as usize]; // å–ğŸ¬
                    contained_boxes[cur_box as usize].iter().for_each(|&new_box| {t_set.insert(new_box);}); // æ”¾æ–°ç®±å­
                    keys[cur_box as usize].iter().for_each(|&key| {keys_set.insert(key);}); // æ‹¿ğŸ”‘
                    have_new_boxes = true;
                } else {
                    // å¦‚æœä¸è¡Œï¼Œå°±å†æŠŠè¿™ä¸ªç®±å­æ‹¿åœ¨æ‰‹é‡Œ
                    t_set.insert(cur_box);
                }
            }
            
            boxes_set = t_set;
        }
        
        ans
    }
}
```