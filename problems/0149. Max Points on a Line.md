> https://leetcode-cn.com/problems/max-points-on-a-line/

``` rust
use std::collections::HashMap;

impl Solution {
    // è¿™é“é¢˜é’ˆä¸æˆ³
    // ä¸ºäº†æ±‚å…±çº¿ç‚¹çš„æœ€å¤§æ•°é‡ï¼Œæˆ‘ä»¬å¯ä»¥:
    // å›ºå®š'åŸºå‡†ç‚¹': points[i] = (x1, y1) (0 <= i < points.len() - 1)
    // éå†'å…¶å®ƒç‚¹': points[j] = (x2, y2) (i < j < points.len())
    // æµ‹ç®—è¿™ä¸¤ç‚¹çš„æ–œç‡ kj = (y2 - y1) / (x2 - x1)
    // å› ä¸ºæ¯ä¸€è½®åŸºå‡†ç‚¹æ˜¯å›ºå®šçš„, æ‰€ä»¥å½“éå†åç»­'å…¶å®ƒç‚¹'æ—¶ï¼Œå¦‚æœå‡ºç°äº†'å…¶å®ƒç‚¹1'ä¸'å…¶å®ƒç‚¹2'åˆ†åˆ«ä¸åŸºå‡†ç‚¹çš„æ–œç‡å€¼ç›¸åŒ, å°±è¡¨æ˜è¿™ä¸‰ç‚¹å…±çº¿
    // æˆ‘ä»¬å¯ä»¥é€šè¿‡è®°å½•ä¸'åŸºå‡†ç‚¹'æ–œç‡çš„æ•°é‡æ¥ç»Ÿè®¡å…±çº¿ç‚¹çš„æ•°é‡
    // æ›´å…·ä½“çš„ç¼–ç¨‹ç»†èŠ‚ä¼šåœ¨ç¨åçš„æ­¥éª¤ä¸­å™è¿°
    pub fn max_points(points: Vec<Vec<i32>>) -> i32 {
        // å¦‚æœç‚¹çš„æ•°é‡<=2, ç›´æ¥è¿”å›å³å¯
        if points.len() <= 2 {
            return points.len() as i32;
        }
        
        let mut ans = 0;
        for i in 0..points.len()-1 {
            // ä¾æ¬¡éå†æ¯ä¸€ä¸ªç‚¹ä½œä¸º'åŸºå‡†ç‚¹', ç»Ÿè®¡åç»­æ‰€æœ‰ç‚¹ä¸åŸºå‡†ç‚¹çš„æ–œç‡
            if ans >= points.len() - i || ans > points.len() / 2 {
                // å¦‚æœå½“å‰ç­”æ¡ˆï¼ˆå…±çº¿ç‚¹çš„æ•°é‡ï¼‰å·²ç»å¤§äºç­‰äºå‰©ä½™ç‚¹çš„æ•°é‡, æˆ–æ˜¯å·²ç»å¤§äºæ€»ç‚¹æ•°çš„ä¸€åŠ, è¡¨æ˜åç»­å·²ç»ä¸ä¼šå†æœ‰è¶…è¿‡è¿™ä¸ªå€¼çš„å¯èƒ½ï¼Œå¯ä»¥ç›´æ¥è¿”å›
                break;
            }
            
            // è¿™ä¸ªHashMapæ˜¯ç”¨æ¥è¡¨ç¤º'æœ¬æ–œç‡ -> æœ¬æ–œç‡æ•°é‡'çš„æ˜ å°„
            let mut k_cnt: HashMap<i32, usize> = HashMap::new();
            
            for j in i+1..points.len() {
                // ä¸‹é¢æ¥è®¡ç®—æ–œç‡:
                // å½“å‰'åŸºå‡†ç‚¹': points[i]
                // å½“å‰'å…¶å®ƒç‚¹': points[j]
                // æ–œç‡k = deltaY / deltaX = (points[j][1] - points[i][1]) / (points[j][0] - points[i][0])
                let (mut deltaY, mut deltaX) = (points[j][1] - points[i][1], points[j][0] - points[i][0]);
                // è¿™é‡Œæˆ‘ä»¬éœ€è¦è®¨è®ºä¸€äº›ç»†èŠ‚å’Œç‰¹æ®Šæƒ…å†µ
                // å› ä¸ºæ¶‰åŠé™¤æ³•, æ‰€ä»¥æœ‰å¯èƒ½å‡ºç°æµ®ç‚¹ç²¾åº¦ä¸å¤Ÿï¼Œåˆ†å­åˆ†æ¯å¯èƒ½å‡ºç°0ï¼Œå‡åˆ†æ•°ï¼Œåˆ†å­åˆ†æ¯ç¬¦å·ä¸åŒçš„é—®é¢˜
                // 1. æµ®ç‚¹ç²¾åº¦ä¸å¤Ÿ: æˆ‘ä»¬å¯ä»¥ä¸è¿›è¡Œé™¤æ³•è¿ç®—ï¼Œç›´æ¥è®°å½•åˆ†å­'deltaY'å’Œåˆ†æ¯'deltaX'çš„å€¼
                // 2. åˆ†å­åˆ†æ¯å¯èƒ½å‡ºç°0çš„é—®é¢˜: åˆ†å­ä¸º0è¡¨ç¤ºæ–œç‡ä¸º0, å¹³è¡Œäºxè½´, åˆ†æ¯ä¸º0, æ–œç‡æ— ç©·å¤§, å‚ç›´ä¸xè½´(ä¸ä¼šåŒæ—¶ä¸º0ï¼Œå› ä¸ºä¸å…±ç‚¹)
                // 3. å‡åˆ†æ•°é—®é¢˜: '1/2' ä¸ '2/4'æ˜¯ä¸€æ ·çš„
                // 4. åˆ†å­åˆ†æ¯ç¬¦å·ä¸åŒ: '-1/2' ä¸ '1/-2'æ˜¯ä¸€æ ·çš„
                let k = match (deltaY, deltaX) {
                    (0, x) => 0,          // åˆ†å­ä¸º0, æ–œç‡ä¸º0, å¹³è¡Œäºxè½´
                    (y, 0) => i32::MAX,   // åˆ†æ¯ä¸º0, æ–œç‡æ— ç©·å¤§, å‚ç›´ä¸xè½´, è¿™é‡Œç”¨i32::MAXè¡¨ç¤ºæ— ç©·å¤§
                    (mut y, mut x) => {
                        // é¦–å…ˆå¤„ç†å¯èƒ½çš„å‡åˆ†æ•°é—®é¢˜:
                        let gcdXY = Solution::gcd(x.abs(), y.abs());
                        y /= gcdXY;
                        x /= gcdXY;
                    
                        // æ¥ç€å¤„ç†åˆ†å­åˆ†æ¯å¼‚å·çš„é—®é¢˜, è¿™é‡Œæˆ‘ä»¬ç»Ÿä¸€è®©åˆ†æ¯æ°¸è¿œä¸ºæ­£
                        if x < 0 {
                            y = -y;
                            x = -x;
                        }
                    
                        // å› ä¸ºé¢˜ç›®ä¸­çš„æ•°æ®èŒƒå›´æ˜¯[-10000, 10000], ç»è¿‡è¿™äº›å˜æ¢å
                        // deltaX: [0, 20000]
                        // deltaY: [-20000, 20000]
                        // æˆ‘ä»¬å°±å¯ä»¥ç”¨ä¸€ä¸ªtrick, æŠŠè¿™ä¸¤ä¸ªå€¼æ˜ å°„æˆä¸€ä¸ªi32èŒƒå›´å†…çš„æ•´æ•°: deltaX + 20001 * deltaY å¤§æ¦‚[-400000000, 400000000]
                        x + 20001 * y
                    }
                };
            
                // è®¡ç®—å¥½'k'åæˆ‘ä»¬å°±å¯ä»¥æŠŠè¿™ä¸ªå€¼åŠ å…¥hashmapä¸­
                *k_cnt.entry(k).or_insert(0) += 1;
            }
            
            // æœ¬è½®çš„æœ€åï¼Œè®©æˆ‘ä»¬ç»Ÿè®¡æœ€å¤šçš„kå€¼ï¼Œæ³¨æ„è¿™é‡Œæ˜¯æ–œç‡çš„æ•°é‡ï¼Œæˆ‘ä»¬éœ€è¦ç‚¹çš„æ•°é‡ï¼Œæ‰€ä»¥æœ€åè¿˜éœ€è¦+1(ä¸€ä¸ªæ–œç‡ä»£è¡¨2ä¸ªç‚¹ï¼Œ2ä¸ªç›¸åŒçš„æ–œç‡è¡¨ç¤º3ä¸ªç‚¹...)
            ans = ans.max(k_cnt.iter().fold(0, |cur_max, (_, cnt)| cur_max.max(cnt + 1)));
        }
        
        // 0ms 100.00% 2.2MB 100.00% è€¶âœŒğŸ»ï¼
        ans as i32
    }
    
    fn gcd(n1: i32, n2: i32) -> i32 {
        if n2 != 0 {
            Solution::gcd(n2, n1 % n2)
        } else {
            n1
        }
    }
}
```