> https://leetcode.com/problems/maximize-sum-of-array-after-k-negations/

``` rust
use std::cmp::Ordering::{Less, Equal, Greater};

impl Solution {
    pub fn largest_sum_after_k_negations(nums: Vec<i32>, mut k: i32) -> i32 {
        let mut bias = nums.iter().min().unwrap().to_owned();
        let mut nums_cnt = [0; 256];
        nums.iter().for_each(|&n| nums_cnt[(n-bias) as usize] += 1);
        
        let mut res = 0;
        for i in 0..nums_cnt.len() {
            if nums_cnt[i] == 0 || k == 0 {
                res += (i as i32 + bias) * nums_cnt[i];
                continue;
            }
            
            let curr_num = i as i32 + bias;
            match curr_num.cmp(&0) {
                Less => {
                    let flip_cnt = k.min(nums_cnt[i]);
                    res += curr_num.abs() * flip_cnt + curr_num * (nums_cnt[i] - flip_cnt);
                    k -= flip_cnt;
                },
                Equal => k = 0,
                _ => res += curr_num * nums_cnt[i],
            }
        }
        
        if k & 1 == 1 {
            res -= 2 * nums.iter().map(|&n| n.abs()).min().unwrap_or(0).to_owned();
        }
        
        res
        
    }
}
```