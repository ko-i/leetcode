> https://leetcode-cn.com/problems/escape-a-large-maze/

``` rust
use std::collections::HashSet;

impl Solution {
    pub fn is_escape_possible(blocked: Vec<Vec<i32>>, source: Vec<i32>, target: Vec<i32>) -> bool {
        let blocked = blocked.iter().map(|b| (b[0], b[1])).collect::<HashSet<(i32, i32)>>();
        
        match Solution::check((source[0], source[1]), (target[0], target[1]), &blocked) {
            0 => true,
            1 => false, 
            _ => Solution::check((target[0], target[1]), (source[0], source[1]), &blocked) != 1,
        }
    }
    
    // 返回值:
    // 0: 在有限步数内就连通了
    // 1: src被包围，且在包围圈里没有遇到tar
    // 2: src没有被包围，但不知道tar有没有被包围
    fn check(src: (i32, i32), tar: (i32, i32), blocked: &HashSet<(i32, i32)>) -> i32 {
        let mut prev_q = HashSet::new();
        let mut curr_q = HashSet::new();
        curr_q.insert(src);
        
        let to = [-1, 0, 1, 0, -1];
        for _ in 0..blocked.len() {
            if curr_q.is_empty() {
                return 1;
            }
            
            let mut next_q = HashSet::new();
            
            for &(x, y) in curr_q.iter() {
                if x == tar.0 && y == tar.1 {
                    return 0;
                }
                
                (0..4).for_each(|i| {
                    let n_x = x + to[i];
                    let n_y = y + to[i+1];
                    
                    if n_x >= 0 && n_y >= 0 && n_x < 1000000 && n_y < 1000000 && !blocked.contains(&(n_x, n_y)) && !prev_q.contains(&(n_x, n_y)) && !curr_q.contains(&(n_x, n_y)){
                        next_q.insert((n_x, n_y));
                    }
                });
            }
            
            prev_q = curr_q;
            curr_q = next_q;
        }
        
        2
    }
}
```