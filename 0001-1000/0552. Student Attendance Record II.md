> https://leetcode-cn.com/problems/student-attendance-record-ii/

``` rust
impl Solution {
    // 没想到昨天的I还是简单今天的II就直接困难了, 但是不用怕
    // 看看题目中给的数据规模 '10^5', 时间复杂度应该要控制在O(n)或者O(nlogn)以内
    // 题目中还给出了结果可能要%(10^9+7), 可能会有递推的动作(从n-1天的状态数转移到n天), 动规也就呼之欲出了
    // 接下来就该考虑状态(其实就感觉挺像买卖股票):
    // 依题: 'A'缺勤严格少于2天, 所以我们只用统计缺勤数为0与1下的情况
    //      'L'不能存在连续3天, 所以我们只用统计'L'连续存在0, 1, 2的情况
    //         需要补充的一点是, 我们只用考虑结尾的情况: 结尾有连续1个'L', 结尾有连续2个'L', 因为内部如果有1个2个L, 只要没构成连续3个, 就不会影响自己的出勤奖励
    // 下面看看有存在多少可以拿到出勤奖励状态:
    // 状态1: 总缺勤数'A':0, 末尾连续迟到数'L':0
    // 状态2: 总缺勤数'A':0, 末尾连续迟到数'L':1
    // 状态3: 总缺勤数'A':0, 末尾连续迟到数'L':2
    // 状态4: 总缺勤数'A':1, 末尾连续迟到数'L':0
    // 状态5: 总缺勤数'A':1, 末尾连续迟到数'L':1
    // 状态6: 总缺勤数'A':1, 末尾连续迟到数'L':2
    
    // 下面这一堆是纸老虎, 看着很吓人, 其实都是非常简单朴素的逻辑: 
    // 1. '今天'的状态1(cur_1): 总缺勤数'A':0, 末尾连续迟到数'L':0
    //     (1): 当'今天'正常出勤时, 可由'昨天'的状态1(pre_1), 状态2(pre_2), 状态3(pre_3)转移而来: cur_1 = pre_1 + pre_2 + pre_3
    //     (2): 当'今天'迟到时, 无法由任何'昨天'的状态转移而来
    //     (3): 当'今天'缺勤时, 无法由任何'昨天'的状态转移而来
    //     因为要同时考虑三种情况, 我们需要把这三种可转移状态数求和, 得到'今天'状态数: cur_1 = pre_1 + pre_2 + pre_3
    
    // 2. '今天'的状态2(cur_2): 总缺勤数'A':0, 末尾连续迟到数'L':1
    //     (1): 当'今天'正常出勤时, 无法由任何'昨天'的状态转移而来
    //     (2): 当'今天'迟到时, 可由'昨天'的状态1(pre_1)转移而来: cur_2 = pre_1
    //     (3): 当'今天'缺勤时, 无法由任何'昨天'的状态转移而来
    //     因为要同时考虑三种情况, 我们需要把这三种可转移状态数求和, 得到'今天'状态数: cur_2 = pre_1
    
    // 3. '今天'的状态3(cur_3): 总缺勤数'A':0, 末尾连续迟到数'L':2
    //     (1): 当'今天'正常出勤时, 无法由任何'昨天'的状态转移而来
    //     (2): 当'今天'迟到时, 可由'昨天'的状态2(pre_2)转移而来: cur_3 = pre_2
    //     (3): 当'今天'缺勤时, 无法由任何'昨天'的状态转移而来
    //     因为要同时考虑三种情况, 我们需要把这三种可转移状态数求和, 得到'今天'状态数: cur_3 = pre_2
    
    // 4. '今天'的状态4(cur_4): 总缺勤数'A':1, 末尾连续迟到数'L':0
    //     (1): 当'今天'正常出勤时, 可由'昨天'的状态4(pre_4), 状态5(pre_5), 状态6(pre_6)转移而来: cur_4 = pre_4 + pre_5 + pre_6
    //     (2): 当'今天'迟到时, 无法由任何'昨天'的状态转移而来
    //     (3): 当'今天'缺勤时, 可由'昨天'的状态1(pre_1), 状态2(pre_2), 状态3(pre_3)转移而来: cur_4 = pre_1 + pre_2 + pre_3
    //     因为要同时考虑三种情况, 我们需要把这三种可转移状态数求和, 得到'今天'状态数: cur_4 = pre_1 + pre_2 + pre_3 + pre_4 + pre_5 + pre_ 6
    
    // 5. '今天'的状态5(cur_5): 总缺勤数'A':1, 末尾连续迟到数'L':1
    //     (1): 当'今天'正常出勤时, 无法由任何'昨天'的状态转移而来
    //     (2): 当'今天'迟到时, 可由'昨天'的状态4(pre_4)转移而来: cur_5 = pre_4
    //     (3): 当'今天'缺勤时, 无法由任何'昨天'的状态转移而来
    //     因为要同时考虑三种情况, 我们需要把这三种可转移状态数求和, 得到'今天'状态数: cur_5 = pre_4
    
    // 6. '今天'的状态6(cur_6): 总缺勤数'A':1, 末尾连续迟到数'L':2
    //     (1): 当'今天'正常出勤时, 无法由任何'昨天'的状态转移而来
    //     (2): 当'今天'迟到时, 可由'昨天'的状态5(pre_5)转移而来: cur_6 = pre_5
    //     (3): 当'今天'缺勤时, 无法由任何'昨天'的状态转移而来
    //     因为要同时考虑三种情况, 我们需要把这三种可转移状态数求和, 得到'今天'状态数: cur_6 = pre_5
    
    pub fn check_record(n: i32) -> i32 {
        // 因为只涉及昨天的六个状态, 所以我们只用设置6个变量即可
        let (s1, s2, s3, s4, s5, s6) = (0..n).fold((1, 0, 0, 0, 0, 0), |s, _| ((s.0 + s.1 + s.2) % 1000000007i64, s.0, s.1, (s.0 + s.1 + s.2 + s.3 + s.4 + s.5) % 1000000007i64, s.3, s.4));
        ((s1 + s2 + s3 + s4 + s5 + s6) % 1000000007i64) as i32  // 记得最后要求和
    }
}
```