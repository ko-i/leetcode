> https://leetcode-cn.com/problems/cat-and-mouse/

``` rust
impl Solution {
    pub fn cat_mouse_game(graph: Vec<Vec<i32>>) -> i32 {
        // çŠ¶æ€æ˜¯ä»€ä¹ˆï¼ŸçŠ¶æ€å°±æ˜¯ï¼ˆå½“å‰å›åˆï¼ŒğŸ­çš„ä½ç½®ï¼ŒğŸ±çš„ä½ç½®ï¼‰
        // cache[step][i][j] è¡¨ç¤º åœ¨stepå›åˆæ—¶ï¼ŒğŸ­åœ¨ç‚¹iï¼ŒğŸ±åœ¨ç‚¹jæ—¶çš„èƒœè´ŸçŠ¶æ€
        // å½“stepä¸ºå¶æ•°æ—¶ï¼ŒğŸ­ç§»åŠ¨ï¼Œå½“stepä¸ºå¥‡æ•°æ—¶ï¼ŒğŸ±ç§»åŠ¨
        // cache[step][i][j] == 0 è¡¨ç¤ºå¹³å±€
        // cache[step][i][j] == 1 è¡¨ç¤ºğŸ­èƒœ
        // cache[step][i][j] == 2 è¡¨ç¤ºğŸ±èƒœ
        let mut cache = vec![vec![vec![-1; graph.len()]; graph.len()]; graph.len() * 2 + 1];
        Solution::dfs(0, 1, 2, &graph, &mut cache)
    }
    
    fn dfs(step: usize, mouth_addr: usize, cat_addr: usize, graph: &Vec<Vec<i32>>, cache: &mut Vec<Vec<Vec<i32>>>) -> i32 {
        if step >= cache.len() {
            return 0;
        }
        
        if mouth_addr == 0 {
            // è€é¼ åœ¨æ´é‡Œ
            return 1;
        }
        
        if cat_addr == mouth_addr {
            return 2;
        }
        
        if cache[step][mouth_addr][cat_addr] != -1 {
            return cache[step][mouth_addr][cat_addr];
        }
        
        match step & 1 {
            0 => {
                // è€é¼ çš„å›åˆ
                let mut can_draw = false;
                for &next in graph[mouth_addr].iter() {
                    match Solution::dfs(step+1, next as usize, cat_addr, graph, cache) {
                        0 => can_draw = true,
                        1 => {
                            cache[step][mouth_addr][cat_addr] = 1;
                            return 1;
                        },
                        _ => (),
                    }   
                }
                
                cache[step][mouth_addr][cat_addr] = if can_draw {0} else {2};
            },
            _ => {
                // çŒ«å’ªçš„å›åˆ
                let mut can_draw = false;
                for &next in graph[cat_addr].iter() {
                    if next == 0 {
                        // çŒ«å’ªå¤ªèƒ–äº†
                        continue;
                    }
                    
                    match Solution::dfs(step+1, mouth_addr, next as usize, graph, cache) {
                        0 => can_draw = true,
                        2 => {
                            cache[step][mouth_addr][cat_addr] = 2;
                            return 2;
                        },
                        _ => (),
                    }   
                }
                
                cache[step][mouth_addr][cat_addr] = if can_draw {0} else {1};
            }
        }
        
        return cache[step][mouth_addr][cat_addr];
    }
}
```