> https://leetcode-cn.com/problems/arithmetic-slices-ii-subsequence/

``` rust
impl Solution {
    // 看完了今天的题之后发现, 昨天的说法是'子数组'是连续的, 今天的说法是'子序列'是不连续的
    // 不连续的话就不能 「一层 + 一遍」 遍历搞定, 能初步想到的就是动态规划, 在结合题中数据规模<=1000, 时间复杂度应该可以到O(n^2)
    // 综上可以考虑二维的动规, 但具体如何做呢
    // 在昨天的思想基础上, 我们可以初步定下一个1维的动规dp[i]表示以nums中第i个元素nums[i]为最后一项的等差数列数量是多少
    // 这里先来个粗略的例子将1维dp推进到2维:
    //    i = [0, 1, 2, 3, 4, 5, 6]
    // nums = [0, 1, 2, 3, 4, 6, 8]
    // 当我们在考虑第4个元素: 即i = 4, nums[4] = 4, dp[4]时
    // 朴素的思想是我们需要遍历它之前的所有元素nums[j](作为倒数第二项), 0 <= j < i, 分别计算出对应的公差:
    //      d[i, j] = nums[i] - nums[j]
    //   0. d[4, 0] = nums[4] - nums[0] = 4
    //   1. d[4, 1] = nums[4] - nums[1] = 3
    //   2. d[4, 2] = nums[4] - nums[2] = 2
    //   3. d[4, 3] = nums[4] - nums[3] = 1
    // 这时候我们就有些感觉了, 再重新汇总一下:
    // 我们将nums[i]作为等差数列的倒数第一项, 将nums[j]作为等差数列的倒数第二项, 这个等差数列的公差d[i, j] = nums[i] - nums[j]
    // 下面我们就自然而然的想到啦, 只要找到以nums[i]为倒数第一项, nums[j]作为倒数第二项, d[i, j]为公差的等差数列有多少个就好了
    // dp[i] = sum(dp[j]) 0 <= j < i
    // dp[i] = dp[0] + dp[1] + dp[2] + dp[3] ... + dp[i-1]
    // 当然没这么简单, 我们还缺少对公差d的限制, 而这个公差d的限制就很自然的成为了dp的第2维:
    // 完整的dp定义: dp[i][d] 表示以nums中第i个数字为结尾, 公差为d的等差数列数量
    // dp[i][d] = sum(dp[j][d] + 1) 其中0 <= j < i, d = nums[i] - nums[j]
    // dp[i][nums[i] - nums[j]] = sum(dp[j][nums[i] - nums[j]] + 1)
    // 晕了吗?
    pub fn number_of_arithmetic_slices(nums: Vec<i32>) -> i32 {
        // 以上我们需要记录公差d, 但d肯能的取值范围很大, 数组存不下, 就只能用hash来存
        // dp[i][d] 表示以nums[i]为末项, 公差为d, 的等差数列数量
        // dp[i]是一个哈希映射, 存储的是特定公差及其对应的等差数列数量
        // 这里也需要解释一下为什么要专门设置一个答案变量而不像一般的dp那样直接以'最后一项'作为答案:
        // 因为我们dp[i][d]的定义是严格以nums[i]为结尾的等差数列个数, 所以我们需要在计算过程中记录每一步统计出的等差数列数量
        // 写到这里我又有了新思路, 也可以尝试实现另一种dp[i][d]: 表示在范围nums[0..i]中以d为公差的等差数列数量(其实区别就是在后续内部循环时稍有不同)
        
        // 下面开始我们的两层循环:
        // 首先最外层从左到右遍历nums中的每一个元素, 考察以当前元素作为末项的情况
        //    然后我们遍历nums[0..i]中不同的元素nums[j], 作为倒数第二项
        //       (1). 求出当前公差d = nums[i] - nums[j]
        //       (2). 我们找到以j(不是i)为末项, d为公差的等差数列数量
        //       (3). 然后我们给答案加上这个值
        //       (4). 最后我们在dp[i][d]中存储cur_cnt并加1(因为)
        //       注意(1), (2), (3), (4)顺序不能变
        //       j 从0取到i(左闭右开)可以避免单元素的情况, 而在更新数值(4)之前进行(2)可以规避双元素的情况
        // 老实写了这么多注释, 也该让我整点花活啦, 别怀疑, 下面这一行过程确实和上面写的一样
        (0..nums.len()).fold((0, vec![std::collections::HashMap::new(); nums.len()]), |(ans, mut dp), i| (ans + (0..i).fold((0, nums[i] as i64 - nums[0] as i64), |(inner_cnt, d), j| (inner_cnt + {*dp[i].entry(d).or_insert(0) += *dp[j].get(&d).unwrap_or(&0) + 1; *dp[j].get(&d).unwrap_or(&0)}, nums[i] as i64 - nums[j+1] as i64)).0, dp)).0
    }
}
```