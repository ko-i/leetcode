> https://leetcode-cn.com/problems/smallest-good-base/

``` rust
impl Solution {
    pub fn smallest_good_base(n: String) -> String {
        // 总和为n, 进制为k, 结合好进制(全为1)的定义, 即:
        // 公式1: n = k^0 + k^1 + k^2 + ... + k^(m-1) + k^m
        // 这里要求最小好进制，即要求k值尽可能小，也即m值(转换后的'bit'位数)尽可能大
        // 依照等比数列的前n项和公式，公式1可化为:
        // n = (1 - k^(m+1)) / (1 - k)
        // 又依照题意，k >= 2，所以1-k不为0，上式可以转化为
        // => (1-k)*n = 1 - k^(m+1)
        // => k^(m+1) = kn - n + 1 < kn
        // => k^(m+1) < kn
        // =>     k^m < n
        // =>       m < logk(n)
        // 这里我们就求出了m的上界m_max = logk(n): 以k为底n的对数
        // 对数函数随底数k增大而减小，随真数n增大而增大
        // 这时候我们还不确定定k的取值，但依照题意，k>=2，n是给定的值，所以可以取k=2时得到本题m值的最大上界
        // m_max = log2(n)
        let n: i64 = n.parse().unwrap();
        for m in (2..=(n as f64).log2() as i64).rev() {
            // 这时我们就把答案限制在一个很小的范围内了[2, m_max]
            // 又因为我们最终所求k值要尽可能小，即要求m的值要尽可能大，所以我们待会儿可以从大到小遍历m的值，找到第一个符合要求的k值即返回
        
            // 下面考虑如何寻找符合要求的k值(因为我们遍历可能的m取值，所以下面这些步骤可以把m当成已知量)
            // 公式1: n = k^0 + k^1 + k^2 + ... + k^(m-1) + k^m
            //    => n > k^m
            //    => k < n.sqrt(m)  (对n开m方根)
            // 公式2(二项式定理)(展开后的公式省略了): 
            //        (k+1)^m = ... > k^0 + k^1 + ... + k^(m-1) + k^m = n
            //    =>  (k+1)^m > n
            //    =>      k+1 > n.sqrt(m) (对n开m方根)
            // 综上:  k < n.sqrt(m) < k+1
            // 这里就限制住在当前n与m的取值情况下，k值应该为int(n.sqrt(m))
            
            // 针对每个m，计算出相应的k值:
            let k = (n as f64).powf(1.0 / m as f64) as i64;
            // 而具体判断k值是否满足条件，用公式1即可
            if (0..=m).fold((0, 1), |(sum, mul), _| (sum + mul, mul * k)).0 == n {
                return k.to_string();
            }
        }
        
        // 0ms 100.00% 2.7MB 100.00% 耶✌🏻！
        // 如果未找到合适的k
        (n-1).to_string()
    }
}
```