> https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/

``` rust
struct SummaryRanges {
    // 得益于题目数据规模不大(<= 10000)
    // 我们一个维护一个数组id
    // id[i] 表示下一步区间索引位置
    //    如果id[i] 比 i 大, 那么表示一个有效区间[i, id[i]]
    //    如果id[i] 比 i 小, 那么表示一个有效区间[id[i], i]
    id: Vec<i32>,
    max_value: usize,   // 可以用于优化查询
}

impl SummaryRanges {
    fn new() -> Self {
        let id = vec![-1; 16384];
        Self {
            id,
            max_value: 0,
        }
    }
    
    fn add_num(&mut self, val: i32) {
        if self.id[val as usize] != -1 {
            // 如果val在之前已经插入过了, 就直接返回
            return;
        }
        
        self.max_value = self.max_value.max(val as usize);
        self.id[val as usize] = val;
        
        if self.id[val as usize + 1] != -1 {
            // 如果val的右侧有区间, 做一些奇怪的修改
            let right_idx = self.id[val as usize + 1] as usize;
            let t_val = self.id[val as usize];
            self.id[t_val as usize] = right_idx as i32;
            self.id[right_idx] = t_val;
        }
        
        if val > 0 && self.id[val as usize - 1] != -1 {
            // 如果val的左侧有区间, 做一些奇怪的修改
            let left_idx = self.id[val as usize - 1] as usize;
            let t_val = self.id[val as usize];
            self.id[t_val as usize] = left_idx as i32;
            self.id[left_idx] = t_val;
        }
    }
    
    fn get_intervals(&self) -> Vec<Vec<i32>> {
        let mut ans = Vec::new();
        let mut idx = 0;
        while idx < self.max_value + 1 {
            if self.id[idx] == -1 {
                idx += 1;
                continue;
            }
            
            ans.push(vec![idx as i32, self.id[idx]]);
            idx = self.id[idx] as usize + 1;
        }
        
        ans
    }
}
```