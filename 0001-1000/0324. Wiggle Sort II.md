> https://leetcode-cn.com/problems/wiggle-sort-ii/

``` rust
use std::cmp::Ordering::{Less, Equal, Greater};

impl Solution {
    pub fn wiggle_sort(nums: &mut Vec<i32>) {
        // é¦–å…ˆæˆ‘ä»¬éœ€è¦æ‰¾åˆ°numsçš„ä¸­ä½æ•°, å¹¶å°†å…¶æ”¾åœ¨numsçš„ä¸­é—´ä½ç½®ä¸Š, æˆ‘ä»¬éœ€è¦è€ƒè™‘å…ƒç´ ä¸ªæ•°å¥‡å¶çš„ä¸åŒæƒ…å†µ
        //    ğŸŒ°                idx = [0, 1, 2, 3, 4, 5, 6] => [0, 1, 2, 3, 4, 5, 6]
        // å¥‡æ•°ğŸŒ°(n=7, n/2=3): nums1 = [1, 5, 1, 1, 6, 4, 3] => [1, 1, 1, 3, 4, 5, 6]
        // å¶æ•°ğŸŒ°(n=6, n/2=3): nums2 = [1, 5, 1, 1, 6, 4]    => [1, 1, 1, 4, 5, 6]
        // é€šè¿‡ä¸Šè¿°ğŸŒ°æˆ‘ä»¬å¯ä»¥çœ‹å‡º, ä¸è®ºå¥‡å¶, æˆ‘ä»¬éƒ½å¯ä»¥ç›´æ¥ä½¿ç”¨nums.len() / 2
        // æœ€åç»“æœæ˜¯æŠŠæ•°ç»„åˆ†å‰²ä¸ºä¸¤ä»½: nums1_a = nums1[0..nums.len()/2] ä¸ nums1_b = nums1[nums.len()/2..]
        // å…¶ä¸­ä¸­ä½æ•°å¤„äºnums1[nums.len()/2]
        // (1). å¦‚æœæ˜¯å¥‡æ•°, nums1_bä¼šæ¯”nums1_aå¤šä¸€ä¸ªå…ƒç´  (2). å¦‚æœæ˜¯å¶æ•°, nums1_aä¸­å…ƒç´ ä¸ªæ•°ä¸nums1_bä¸­å…ƒç´ ä¸ªæ•°ç›¸åŒ
        
        // ç°åœ¨çš„ç›®æ ‡å°±å¾ˆæ˜ç¡®äº†, æˆ‘ä»¬éœ€è¦å½“æ•°ç»„ä¸­ç¬¬'nums.len()/2'å°çš„å…ƒç´ , æ”¾åœ¨ç´¢å¼•'nums.len()/2'ä¸Š
        // è¦æ³¨æ„çš„æ˜¯è¿™é‡Œå¯ä»¥ä»0å¼€å§‹, ä¹Ÿå°±æ˜¯ç¬¬'0'å°, ç¬¬'1'å°, ...
        let n = nums.len();
        Solution::quick_select(nums, 0, n - 1, n / 2);
        let median = nums[n/2];  // ä¸­ä½æ•°å°±æ˜¯å®ƒäº†
        
        // å› ä¸ºå¯èƒ½å‡ºç°é‡å¤å…ƒç´ , ä¸‹é¢æˆ‘ä»¬ä½¿ç”¨ä¸‰è·¯åˆ’åˆ†çš„æ–¹æ³•, æŠŠæ‰€æœ‰æ¯”ä¸­ä½æ•°å°çš„æ•°æ”¾åœ¨ä¸­ä½æ•°å·¦è¾¹, æ¯”ä¸­ä½æ•°å¤§çš„æ•°æ”¾åœ¨ä¸­ä½æ•°å³è¾¹
        let (mut l, mut cur_idx, mut r) = (0, 0, nums.len()-1);
        while cur_idx < r {
            match nums[cur_idx].cmp(&median) {
                Less => {
                    nums.swap(l, cur_idx);
                    cur_idx += 1;
                    l += 1;
                },
                Equal => cur_idx += 1,
                Greater => {
                    nums.swap(cur_idx, r);
                    r -= 1;
                }
            }
        }
        
        // ç»è¿‡å¦‚ä¸Šçš„å˜æ¢, æœ¬é¢˜ä¸­çš„ä¸¤ä¸ªğŸŒ°å˜ä¸º:
        //    ğŸŒ°                idx = [0, 1, 2, 3, 4, 5, 6] => [0, 1, 2, '3', 4, 5, 6]    æœ€ç»ˆæœ€å¥½èƒ½å˜æˆä¸‹æ–¹çš„æ ·å­:
        // å¥‡æ•°ğŸŒ°(n=7, n/2=3): nums1 = [1, 5, 1, 1, 6, 4, 3] => [1, 1, 1, '3', 4, 5, 6] => [1, 4, 1, 5, 1, 6, 3]
        // å¶æ•°ğŸŒ°(n=6, n/2=3): nums2 = [1, 5, 1, 1, 6, 4]    => [1, 1, 1, '4', 5, 6]    => [1, 4, 1, 5, 1, 6]
        // è¿™æ—¶å€™æˆ‘ä»¬å‘ç°, å¦‚æœæ˜¯å¥‡æ•°ä¸ª, æˆ‘ä»¬éœ€è¦è®©å·¦åŠéƒ¨åˆ†æ¯”å³åŠéƒ¨åˆ†å¤š1
        let mid_idx = nums.len() / 2 + if nums.len() % 2 == 0 {0} else {1};
        let (arr_l, arr_r) = (nums[0..mid_idx].to_vec(), nums[mid_idx..].to_vec());
        // æœ€åå€’åºç©¿æ’å³å¯
        (0..arr_l.len()).for_each(|i| nums[2 * i] = arr_l[arr_l.len() - i - 1]);
        (0..arr_r.len()).for_each(|i| nums[2 * i + 1] = arr_r[arr_r.len() - i - 1]);
    }
    
    // è¾…åŠ©å‡½æ•°, å¿«é€Ÿé€‰æ‹©: quick_select
    // è¿™ä¸ªå‡½æ•°æ¥å—ä¸€ä¸ªæ•°ç»„, åŠå…¶å¯¹åº”çš„èŒƒå›´nums[begin..end](åˆ‡ç‰‡), å°†ç¬¬kå°çš„æ•°æ”¾åœ¨ç¬¬kä¸ªä½ç½®nums[begin+k]ä¸Š, è¿™é‡Œkå¯ä»¥å–0
    fn quick_select(nums: &mut Vec<i32>, begin: usize, end: usize, k: usize) {
        // é¦–å…ˆæˆ‘ä»¬é€‰å–ä¸€ä¸ªå€¼flag, ä¸€èˆ¬æ˜¯å¼€å¤´nums[begin]æˆ–ç»“å°¾nums[end]
        // ç„¶åæˆ‘ä»¬è¦å°†æ‰€æœ‰æ¯”flagå°çš„æ•°æ”¾åœ¨flagå·¦è¾¹, æ¯”flagå¤§çš„æ•°æ”¾åœ¨flagå³è¾¹, é‡åˆ°ä¸flagç›¸åŒçš„æ•°, æˆ‘ä»¬å…ˆä¸ç®¡å®ƒ
        let (mut l, mut r) = (begin, end);
        let flag = nums[r];
        while l < r { // å¾ªç¯æ¡ä»¶, å¦‚æœl==rè¡¨ç¤ºåªæœ‰ä¸€ä¸ªå…ƒç´ , æ²¡å•¥å¯é€‰æ‹©çš„äº†
            while l < r && nums[l] <= flag {
                // æˆ‘ä»¬æ‰¾åˆ°å·¦åŠè¾¹ç¬¬ä¸€ä¸ªæ¯”flagå¤§çš„æ•°
                l += 1;
            }
            
            if l < r {
                nums[r] = nums[l];
            }
            
            while l < r && nums[r] >= flag {
                r -= 1;
            }
            
            if l < r {
                nums[l] = nums[r];
            }
        }
        
        // è®°å¾—æŠŠflagæ”¾ä¼šåˆ°å±äºå®ƒçš„ä½ç½®ä¸Š(æœ€åçš„ç©ºä½)
        nums[l] = flag;
        
        // ç„¶åæ£€æŸ¥lä¸kçš„å€¼
        match l.cmp(&k) {
            // å¦‚æœæœ€ç»ˆlçš„å€¼æ¯”kå°, è¯´æ˜æˆ‘ä»¬ç›®å‰æœ‰l+1ä¸ªå…ƒç´ å¤„åœ¨äº†æ­£ç¡®çš„ä½ç½®ä¸Š, ä½†è¿˜ä¸å¤Ÿ, æˆ‘ä»¬éœ€è¦åœ¨å³åŠè¾¹ç»§ç»­å¯»æ‰¾
            Less => Solution::quick_select(nums, l+1, end, k),
            // å¦‚æœlä¸kç›¸ç­‰, é‚£æˆ‘ä»¬æ‰¾åˆ°äº†è¿™ä¸ªå€¼, ä¸ç”¨ç»§ç»­æŸ¥æ‰¾äº†
            Equal => (), 
            // å¦‚æœlæ¯”kå¤§, è¯´æ˜æˆ‘ä»¬åšçš„è¿‡å¤´äº†, æˆ‘ä»¬å°±æ‰¾åœ¨å·¦åŠè¾¹ç»§ç»­å¯»æ‰¾
            Greater => Solution::quick_select(nums, begin, l-1, k),
        }
    }
}
```