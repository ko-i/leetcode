> https://leetcode-cn.com/problems/minimize-malware-spread-ii/

``` rust
use std::collections::HashSet;

impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, mut initial: Vec<i32>) -> i32 {

        let mut is_cleaned = vec![true; graph.len()];
        initial.iter().for_each(|i| is_cleaned[*i as usize] = false);
        
        let mut infectied_by = vec![vec![]; graph.len()];
        initial.iter().for_each(|&i| {
            let mut seen = HashSet::new();
            Solution::dfs(i as usize, &graph, &mut seen, &is_cleaned);
            
            seen.iter().for_each(|&infect| infectied_by[infect as usize].push(i as usize));
        });
        
        // 要找到只售一个影响的
        let mut valid_cnt = vec![0; graph.len()];
        (0..infectied_by.len()).for_each(|i| if infectied_by[i].len() == 1 {
            valid_cnt[infectied_by[i][0] as usize] += 1;
        });
        
        initial.sort_unstable();
        let mut res = initial[0];
        let mut max_infectied = -1;
        initial.iter().for_each(|&src| if valid_cnt[src as usize] > max_infectied {
            res = src;
            max_infectied = valid_cnt[src as usize];
        });
        
        res
    }
    
    fn dfs(curr: usize, graph: &Vec<Vec<i32>>, seen: &mut HashSet<usize>, is_cleaned: &Vec<bool>) {
        for next in 0..graph.len() {
            if graph[curr][next] == 1 && !seen.contains(&next) && is_cleaned[next] {
                seen.insert(next);
                Solution::dfs(next, graph, seen, is_cleaned);
            }
        }
    }
}
```