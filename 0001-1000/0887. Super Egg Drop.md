> https://leetcode-cn.com/problems/super-egg-drop/

``` rust
use std::cmp::Ordering::{Less, Equal, Greater};

impl Solution {
    pub fn super_egg_drop(k: i32, n: i32) -> i32 {
        // dp[i][j] 代表i个🥚(0<=i<=k), j层楼(0<=j<=n)时, 确定f值的最小操作个数
        let mut dp = vec![vec![0; n as usize + 1]; k as usize + 1];
        // 1. 考虑边界条件:
        // 1.1. 当有0层楼时(对应dp[..][0]), 不管有多少🥚, 我们都用不到
        // 1.2. 当有0个🥚时(对应dp[0][..]), 只有dp[0][0]是有意义的, 一旦楼层数大于0, 我们没办法试出来, 选取一个大数, 表示无意义
        (1..dp[0].len()).for_each(|j| dp[0][j] = usize::MAX);
        // 其实最后状态转移也用不到i == 0 与 j == 0时的情况, 这样讨论感觉会完备一些(在之后的研究中也发现对0层楼赋值为0对后续状态转移时处理边界条件有帮助)
        // 1.3. 只有1个🥚时(对应dp[1][1..]), 有几层楼, 就需要试几次(一层一层往上试)
        (1..dp[1].len()).for_each(|j| dp[1][j] = j);
        // 1.4. 只有1层楼时(对应dp[1..][1]), 不管有多少🥚, 只用试一次(当然, 0个🥚除外)
        (1..dp.len()).for_each(|i| dp[i][1] = 1);
        
        // 2. 下面考虑状态转移: 当我们拿着i个🥚(这里i>=2)面对j层楼时:
        // 我们可以取一个🥚, 让其从k层扔下(k任选, 1<=k<=j), 这时会出现两种情况, 1. 🥚碎了, 2. 🥚没碎,对应两种状态转移
        // 2.1 🥚碎了: 这时候状态变为dp[i-1][k-1] (我们少了一个🥚, 但是我们把下一步的测试范围缩减到了[1..=k-1], 因为我们知道了第k层也是不安全的, 所以我们可以排除掉第k层, 只保留前面的k-1层)
        //     对应状态转移方程: dp[i][j] = dp[i-1][k-1] + 1 (最后+1表示我们进行的这次扔🥚操作)
        // 2.2 🥚没碎: 这时候状态变为dp[i][j-k] (这里变为j-k值得细致分析一下, 我们可以想象如果取k==j, 那么如果这次没碎, 就会转换为dp[i][0], 是正确的)
        //     对应状态转移方程: dp[i][j] = dp[i][j-k] + 1 (最后+1表示我们进行的这次扔🥚操作)
        // 最后我们需要的就是这两个方程中较大的那个结果(因为我们要保证最坏情况): 1 + max(dp[i-1][k-1], dp[i][j-k])
        // 但还没结束, 因为k是我们随机取的, 它可以取到[1..=j]中任意一个值
        // 所以我们需要遍历[1..=j], 找到其中所有最坏情况的最小值: min(1 + max(dp[i-1][k-1], dp[i][j-k]))
        // 我们分别观察关键的这两项: dp[i-1][k-1]与dp[i][j-k]
        // f1(k) = dp[i-1][k-1] (1<=k<=j) 随着k的增大而增大(很朴素的道理: 🥚数不变, 楼层越多, 所需要的尝试次数越多)
        // f2(k) = dp[i][j-k] (1<=k<=j) 随着k的增大而减小(同上)
        // 这时候我们只要找到一个t_k, 使得f1(t_k) == f2(t_k), 即是最小的较大值
        // 但我们题目中数据是离散的, 不一定能取得这个t_k值, 所以我们需要把条件放宽一些:
        // 找到一个t_kl, 满足f1(tk_l) <= f2(tk_l)
        // 找到一个t_kr, 满足f1(tk_r) >  f2(tk_r)
        // 我们可以通过二分的方法来找
        
        (2..dp.len()).for_each(|i| (2..dp[i].len()).for_each(|j| {
            // 在最内部的循环中, 我们需要用二分的方法来查找最小的较大值
            let (mut t_kl, mut t_kr) = (0, j);
            while t_kl + 1 < t_kr { // 因为最后要找到两个点, 所以在剩下最后两个点时我们就返回
                let cur_k = (t_kl + t_kr) / 2; // 找到中间那个点
                let (f1, f2) = (dp[i-1][cur_k-1], dp[i][j-cur_k]);
                
                match f1.cmp(&f2) {
                    Less => t_kl = cur_k,  // 如果f1(k) < f2(k), 那么表示这个点在最优点的左边
                    Equal => {
                        // 人品较好, 竟然真的存在这个点
                        t_kl = cur_k;
                        t_kr = cur_k;
                    },
                    Greater => t_kr = cur_k, // 如果f1(k) > f2(k), 那么表示这个点在最优点的右边
                }
            }
            
            // 下面我们就分别代入t_kl与t_kr, 计算最优的结果, 别忘了最后+1
            dp[i][j] = dp[i-1][t_kl-1].max(dp[i][j-t_kl]).min(dp[i-1][t_kr-1].max(dp[i][j-t_kr])) + 1;
        }));
        
        dp[k as usize][n as usize] as i32
    }
}
```