> https://leetcode-cn.com/problems/minimize-malware-spread/

``` rust
impl Solution {
    pub fn min_malware_spread(graph: Vec<Vec<i32>>, initial: Vec<i32>) -> i32 {
        
        // colors[i] 表示节点i的颜色
        let mut colors = vec![-1; graph.len()];
        let mut curr_color = 0;
        
        (0..graph.len()).for_each(|i| if colors[i] == -1 {
            Solution::dfs(i, curr_color, &graph, &mut colors);
            curr_color += 1;
        });
        
        //
        let mut color_cnt = vec![0; curr_color as usize];
        colors.iter().for_each(|&c| color_cnt[c as usize] += 1);
        
        let mut initial_color_cnt = vec![0; curr_color as usize];
        initial.iter().for_each(|&n| initial_color_cnt[colors[n as usize] as usize] += 1);
        
        let mut max_cut = 0;
        let mut res = i32::MAX;
        initial.iter().for_each(|&n| if initial_color_cnt[colors[n as usize] as usize] == 1 {
            if max_cut < color_cnt[colors[n as usize] as usize] {
                max_cut = color_cnt[colors[n as usize] as usize];
                res = n;
            } else if max_cut == color_cnt[colors[n as usize] as usize] && n < res {
                res = n;
            }
        });
        
        if res == i32::MAX {
            *initial.iter().min().unwrap()
        } else {
            res
        }
    }
    
    fn dfs(node: usize, curr_color: i32, graph: &Vec<Vec<i32>>, colors: &mut Vec<i32>) {
        if colors[node] != -1 {
            return;
        }
        
        colors[node] = curr_color;
        for next_node in 0..graph.len() {
            if next_node != node && graph[node][next_node] == 1 && colors[next_node] == -1 {
                Solution::dfs(next_node, curr_color, graph, colors);
            }
        }
    }
}
```