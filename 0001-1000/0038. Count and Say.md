> https://leetcode.com/problems/count-and-say/

``` rust
impl Solution {
    // 学习一下递归
    pub fn count_and_say(n: i32) -> String {
        if n == 1 {
            // 基本情况
            return "1".to_string();
        }
        
        // 递归地计算前一个数字代表的字符串
        let pre_string = Solution::count_and_say(n-1);
        let p_s_b = pre_string.as_bytes();
        
        (0..p_s_b.len()).fold((String::with_capacity(pre_string.len() * 2), p_s_b[0], 1), |(mut res, cur_num, cnt), i| match i + 1 < p_s_b.len() && p_s_b[i+1] == cur_num {
            true => (res, cur_num, cnt+1),
            _ => {
                res.push((cnt as u8 + b'0') as char);
                res.push(cur_num as char);
                
                (res, if i + 1 < p_s_b.len() {p_s_b[i+1]} else {b'#'}, 1)
            }
        }).0
    }
}
```

``` c
char * countAndSay(int n){
    if(n == 1)
    {
        return "1";
    }
    
    char* prior_str = (countAndSay(n - 1));
    char* current_str = (char*)malloc((2 * strlen(prior_str) + 1) * sizeof(char));
    
    char* scan_p = prior_str;
    char scan_p_prior = '\0';
    int same_count = 1;
    char* scan_c = current_str;
    
    while(1)
    {
        if(*scan_p == scan_p_prior)
        {
            same_count++;
        }
        else
        {
            if(scan_p_prior != '\0')
            {
                *(scan_c++) = '0' + same_count;
                *(scan_c++) = scan_p_prior;
            }
            
            same_count = 1;
        }
        
        if(*scan_p == '\0')
        {
            break;
        }
        
        scan_p_prior = *scan_p;
        scan_p++;
    }
    
    *scan_c = '\0';
    
    if(n > 2)
    {
        free(prior_str);
    }
    
    return current_str;
}
```