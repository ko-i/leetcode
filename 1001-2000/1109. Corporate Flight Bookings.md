> https://leetcode-cn.com/problems/corporate-flight-bookings/

``` rust
impl Solution {
    // 差分? 好像是叫这个名字
    // 以题目中示例1作为简单的小栗子: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5
    // 初始情况: 
    // index: [0, 1, 2, 3, 4, 5]   (因为题目中的起始编号从1开始, 所以这里可以多设置一位 以便能取到索引n)
    //  diff: [0, 0, 0, 0, 0, 0]
    
    // 第一个预订记录: bookings[0] = [1, 2, 10]
    // 我们给差分数组索引为1的地方diff[1] 增加10, 表示从第1个航班往后会多出10个预定记录
    // 我们给差分数组索引为3(因为会记录中是闭区间, 所以这里要给2加上1)的地方diff[3] 减去10, 表示这10个预订记录到第2个航班结束
    // index: [0,  1, 2,   3, 4, 5]
    //  diff: [0, 10, 0, -10, 0, 0]
    
    // 同理这样考虑第2个预订记录: bookings[1] = [2, 3, 20]
    // 我们给差分数组索引为2的地方diff[2] 增加20, 表示从第2个航班往后会多出20个预定记录
    // 我们给差分数组索引为4的地方(因为会记录中是闭区间, 所以这里要给3加上1)diff[4] 减去20, 表示这20个预订记录到第3个航班结束
    // index: [0,  1,  2,   3,   4, 5]
    //  diff: [0, 10, 20, -10, -20, 0]
    
    // 同理这样考虑第3个预订记录: bookings[2] = [2, 5, 25]
    // 我们给差分数组索引为2的地方diff[2] 增加25, 表示从第2个航班往后会多出25个预定记录
    // 我们给差分数组索引为6的地方(因为会记录中是闭区间, 所以这里要给5加上1)diff[6] 减去25, 表示这25个预订记录到第5个航班结束
    // 但我们发现索引6会越界, 所以为了不越界, 我们还需要再多开辟一位, 当然也可以用别的方式实现(加条件判断等等)
    // index: [0,  1,  2,   3,   4, 5,   6]
    //  diff: [0, 10, 25, -10, -20, 0, -25]
    
    // 然后我们就用求前缀和的思想, 从索引1开始每求出一个前缀和, 就将它放入答案数组中即可
    pub fn corp_flight_bookings(bookings: Vec<Vec<i32>>, n: i32) -> Vec<i32> {
        let mut diff = vec![0; n as usize + 2];  // 多设置2位, 一位给0索引, 一位给末尾开区间的索引
        bookings.iter().for_each(|booking| {
            diff[booking[0] as usize] += booking[2];
            diff[booking[1] as usize + 1] -= booking[2];  // 注意这里闭区间的原因, 我们要多加1
        });
        
        (1..diff.len()).for_each(|i| diff[i] += diff[i-1]); // 求出前缀和
        diff[1..diff.len()-1].to_vec() // 注意这里我们需要掐头去尾
    }
}
```